package ch.ge.ve.protopoc.service.algorithm;

import ch.ge.ve.protopoc.service.model.*;
import ch.ge.ve.protopoc.service.support.ByteArrayUtils;
import ch.ge.ve.protopoc.service.support.Conversion;
import com.google.common.base.Preconditions;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Algorithms related to the preparation of code sheets
 */
public class CodeSheetPreparationAlgorithms {
    private final Conversion conversion = new Conversion();
    private final PublicParameters publicParameters;
    private final int s;

    public CodeSheetPreparationAlgorithms(PublicParameters publicParameters) {
        this.publicParameters = publicParameters;
        s = publicParameters.getS();
    }

    /**
     * Algorithm 7.16: GetSheets
     *
     * @param electionSet   the electionSet definition, including v, c, n, k and E
     * @param codeSheetData the secret voter data generated by each authority for each voter
     *                      (codeSheetData.get(j) = bold_d_j : the list of the voters' secret data for authority j)
     * @return all the relevant information combined for printing on the code sheets
     */
    public List<CodeSheet> getSheets(ElectionSet electionSet, List<List<SecretVoterData>> codeSheetData) {
        Preconditions.checkArgument(codeSheetData.size() == publicParameters.getS(),
                String.format("|D| [%d] != s [%d]", codeSheetData.size(), publicParameters.getS()));
        Preconditions.checkArgument(codeSheetData.stream().allMatch(
                secretVoterDatas -> secretVoterDatas.size() == electionSet.getVoters().size()),
                "Each authority should have submitted one code sheet per voter");

        List<CodeSheet> codeSheets = new ArrayList<>();
        for (int i = 0; i < electionSet.getVoters().size(); i++) {
            Voter v_i = electionSet.getVoters().get(i);

            // for each authority, get the secret data pertaining to voter i
            final int local_i = i;
            List<SecretVoterData> secretVoterDataList = codeSheetData.stream()
                    .map(list -> list.get(local_i)).collect(Collectors.toList());

            String X_i = computeX_i(secretVoterDataList);
            String Y_i = computeY_i(secretVoterDataList);
            String F_i = computeF_i(secretVoterDataList);
            List<String> rc_i = computeRC_i(electionSet, secretVoterDataList);
            List<Integer> k_i = computeK_i(electionSet, v_i);

            codeSheets.add(getSheet(electionSet, v_i, X_i, Y_i, F_i, rc_i, k_i));
        }
        return codeSheets;
    }

    /**
     * X_i = ToByteArray( \sum{j=1,s}(x_{ij}), L_x)
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return the byte array conversion of the sum of individual <tt>x_ij</tt>s
     */
    private String computeX_i(List<SecretVoterData> secretVoterDataList) {
        BigInteger sum_x_ij = IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                .map(SecretVoterData::getX)
                .reduce(BigInteger::add).orElseGet(() -> BigInteger.ZERO);
        return conversion.toString(sum_x_ij, publicParameters.getK_x(), publicParameters.getA_x());
    }

    /**
     * Y_i = ToByteArray( \sum{j=1,s}(y_{ij}), L_y)
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return the byte array conversion of the sum of individual <tt>y_ij</tt>s
     */
    private String computeY_i(List<SecretVoterData> secretVoterDataList) {
        BigInteger sum_y_ij = IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                .map(SecretVoterData::getY)
                .reduce(BigInteger::add).orElseGet(() -> BigInteger.ZERO);
        return conversion.toString(sum_y_ij, publicParameters.getK_y(), publicParameters.getA_y());
    }

    /**
     * F_i = \xor{j=1,s}(F_{ij})
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return the result of xoring the individual <tt>F_ij</tt>s
     */
    private String computeF_i(List<SecretVoterData> secretVoterDataList) {
        List<Character> A_f = publicParameters.getA_f();
        return IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                .map(SecretVoterData::getF)
                .reduce(ByteArrayUtils::xor)
                .map(b -> conversion.toString(b, A_f))
                .orElseGet(() -> "");
    }

    /**
     * RC_ik = \xor{j=1,s}(RC_{ijk})
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return for each k, the result of xoring the individual <tt>RC_ijk</tt>s
     */
    private List<String> computeRC_i(ElectionSet electionSet, List<SecretVoterData> secretVoterDataList) {
        List<Character> A_r = publicParameters.getA_r();
        return IntStream.range(0, electionSet.getCandidates().size()).mapToObj(k ->
                IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                        .map(secretVoterData -> secretVoterData.getRc()[k])
                        .reduce(ByteArrayUtils::xor)
                        .map(b -> conversion.toString(b, A_r))
                        .orElseGet(() -> "")
        ).collect(Collectors.toList());
    }

    /**
     * k_i = (e_{i,1} * k_1, ..., e_{i,t} * kt)
     *
     * @param electionSet the electionSet definition, including v, c, n, k and E
     * @param v_i         the individual voter
     * @return the vector of allowed number of selections per election for the voter
     */
    private List<Integer> computeK_i(ElectionSet electionSet, Voter v_i) {
        return electionSet.getElections().stream()
                .map(e -> electionSet.isEligible(v_i, e) ? e.getNumberOfSelections() : 0)
                .collect(Collectors.toList());
    }

    /**
     * Algorithm 7.17: GetSheet
     *
     * @param electionSet the electionSet definition, including v, c, n, k and E
     * @param v_i         the voter
     * @param x_i         the element to be used for identification
     * @param y_i         the element to be used for confirmation
     * @param f_i         the element to be used as finalization code
     * @param rc_i        the vector of the elements to be used for return codes
     * @param k_i         the number of selections the voter can make for each election
     * @return the elements needed for the voter's code sheet
     */
    private CodeSheet getSheet(ElectionSet electionSet, Voter v_i, String x_i, String y_i, String f_i, List<String> rc_i, List<Integer> k_i) {
        return new CodeSheet(v_i, electionSet, k_i, x_i, y_i, f_i, rc_i);
    }
}
